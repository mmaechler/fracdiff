TODO / Ideas   see ---> ./Done  for things finished
------------            ~~~~~~

1. Estimation should produce a class with print(), summary(), coef(),
   logLik() and vcov() methods; maybe also residuals() & fitted(); predict()?
   ==> Maybe use new function names to keep the old back compatibility

 1a. In any case, we want $residuals (as "arima"): ``the fitted innovations''

1c. fracdiff.sim(): think about making it an *generalization* of  arima.sim,
     maybe call the new function arfima.sim() and keep the old one as is.



2. call R's gammafn() and minimizers (Brent is there!), instead of "our own"

4. Consider the diverse filters, e.g.  (0,d,0) --> (p,d,q)
   Now started implementing and testing in *R* :
   --> ./filters.R
       ~~~~~~~~~~~
5. fracdiff() and fracdiff.var()  share much code, including warning
   message generation.  Clean up! See 'FIXME' in R/fracdiff.R !

6. fracdiff.sim():  This really is a *filter* of the innovations.
    in C: 1)  eps_t -->  fARIMA(0, d, 0) =: Y_t
          2)   Y_t  -->  fARIMA(p, d, q) =: Z_t   i.e. a simple ARMA() filter
   --> we should provide the "filter 1)" as a *separate* R function


Hessian --> covariance
======================

3. For the hessian / covariance { src/fdhess.c } :
   Think about trying several step-sizes and use stable ("optimal"?) one.

6. Currently C/Fortran uses old Linpack SVD and its own inverse, and
   just returns warnings if things "fail" there.
   Possibly rather do these in R, and possibly use
   using chol() and chol2inv() rather than svd.
